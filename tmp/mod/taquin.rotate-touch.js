{"intl":"","src":"window['#taquin.rotate-touch']=function(exports,module){  var MOUSEDOWN = 1;\r\nvar TOUCHSTART = 2;\r\n\r\nvar X_AXIS = new THREE.Vector3(1,0,0);\r\nvar Y_AXIS = new THREE.Vector3(0,1,0);\r\n\r\n/**\r\n * Deal with touch/mouse gestures to make an object rotate.\r\n *\r\n * @param canvas {canvas} - the canvas on with we will attach touch/mouse events.\r\n * @param mesh {THREE.Mesh} - the object to rotate according to gestures.\r\n */\r\nvar RotateTouch = function(canvas) {\r\n    var that = this;\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this._tap = false;\r\n    this.rotation = { speedX: Math.random() * .01, speedY: Math.random() * .01 };\r\n    var status = 0;\r\n    var timeTouchStart = 0;\r\n    var time0 = 0;\r\n    canvas.addEventListener(\"touchstart\", function(evt) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        status = TOUCHSTART;\r\n        timeTouchStart = time0 = Date.now();\r\n        var touches = evt.changedTouches;\r\n        if (touches.length > 0) {\r\n            that.x = ( touches[0].clientX / canvas.width ) * 2 - 1;\r\n            that.x0 = that.x;\r\n            that.y = -( touches[0].clientY / canvas.height ) * 2 + 1;\r\n            that.y0 = that.y;\r\n        }\r\n        // Stop rotation as soon as the user touches the screen.\r\n        that.rotation.speedX = that.rotation.speedY = 0;\r\n    });\r\n    canvas.addEventListener(\"touchend\", function(evt) {\r\n        if (status != TOUCHSTART) return;\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        var deltaTime = Date.now() - timeTouchStart;\r\n        if (deltaTime > 400) return;\r\n        var x, y;\r\n        var touches = evt.changedTouches;\r\n        if (touches.length > 0) {\r\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\r\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\r\n        }\r\n        var dis = Math.max(Math.abs(that.x0 - x), Math.abs(that.y0 - y));\r\n        if (dis > 0.05) return;\r\n        that._tap = true;\r\n    });\r\n    canvas.addEventListener(\"touchmove\", function(evt) {\r\n        if (status != TOUCHSTART) return;\r\n        evt.preventDefault();\r\n        var touches = evt.changedTouches;\r\n        var x, y;\r\n        if (touches.length > 0) {\r\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\r\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\r\n            var time1 = Date.now();\r\n            var deltaTime = Math.max(0.001, time1 - time0);\r\n            that.rotation.speedY = (x - that.x) / deltaTime;\r\n            that.rotation.speedX = (y - that.y) / deltaTime;\r\n            that.x = x;\r\n            that.y = y;\r\n            time0 = time1;\r\n        }\r\n    });\r\n\r\n    canvas.addEventListener(\"mousedown\", function(evt) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        status = MOUSEDOWN;\r\n        timeTouchStart = time0 = Date.now();\r\n        that.x = ( evt.clientX / canvas.width ) * 2 - 1;\r\n        that.x0 = that.x;\r\n        that.y = -( evt.clientY / canvas.height ) * 2 + 1;\r\n        that.y0 = that.y;\r\n        // Stop rotation as soon as the user touches the screen.\r\n        that.rotation.speedX = that.rotation.speedY = 0;\r\n    });\r\n    canvas.addEventListener(\"mouseup\", function(evt) {\r\n        if (status != MOUSEDOWN) return;\r\n        status = 0;\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        var deltaTime = Date.now() - timeTouchStart;\r\n        if (deltaTime > 400) return;\r\n        var x, y;\r\n        x = ( evt.clientX / canvas.width ) * 2 - 1;\r\n        y = -( evt.clientY / canvas.height ) * 2 + 1;\r\n        var dis = Math.max(Math.abs(that.x0 - x), Math.abs(that.y0 - y));\r\n        if (dis > 0.05) return;\r\n        that._tap = true;\r\n    });\r\n    canvas.addEventListener(\"mousemove\", function(evt) {\r\n        if (status != MOUSEDOWN) return;\r\n        evt.preventDefault();\r\n        var touches = evt.changedTouches;\r\n        var x, y;\r\n        x = ( evt.clientX / canvas.width ) * 2 - 1;\r\n        y = -( evt.clientY / canvas.height ) * 2 + 1;\r\n        var time1 = Date.now();\r\n        var deltaTime = Math.max(0.001, time1 - time0);\r\n        that.rotation.speedY = (x - that.x) / deltaTime;\r\n        that.rotation.speedX = (y - that.y) / deltaTime;\r\n        that.x = x;\r\n        that.y = y;\r\n        time0 = time1;\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nRotateTouch.prototype.applyRotation = function(mesh, deltaTime) {\r\n    var angX = this.rotation.speedX * deltaTime;\r\n    var angY = -this.rotation.speedY * deltaTime;\r\n    var Cx = Math.cos(angX);\r\n    var Sx = Math.sin(angX);\r\n    var Cy = Math.cos(angY);\r\n    var Sy = Math.sin(angY);\r\n    mesh.matrixAutoUpdate = false;\r\n    var rotation = new THREE.Matrix4();\r\n    var e = rotation.elements;\r\n    e[0]  = Cy;      e[1]  = 0;      e[2]  = Sy;      e[3]  = 0;\r\n    e[4]  = Sx*Sy;   e[5]  = Cx;     e[6]  = -Cy*Sx;  e[7]  = 0;\r\n    e[8]  = -Cx*Sy;  e[9]  = Sx;     e[10] = Cx*Cy;   e[11] = 0;\r\n    e[12] = 0;       e[13] = 0;      e[14] = 0;       e[15] = 1;\r\n\r\n    mesh.matrix = rotation.multiply( mesh.matrix );\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nRotateTouch.prototype.tap = function() {\r\n    if (this._tap) {\r\n        this._tap = false;\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n\r\nmodule.exports = RotateTouch;\r\n }\n","zip":"window[\"#taquin.rotate-touch\"]=function(t,e){var a=1,n=2,i=(new THREE.Vector3(1,0,0),new THREE.Vector3(0,1,0),function(t){var e=this;this.x=0,this.y=0,this._tap=!1,this.rotation={speedX:.01*Math.random(),speedY:.01*Math.random()};var i=0,o=0,r=0;t.addEventListener(\"touchstart\",function(a){a.preventDefault(),a.stopPropagation(),i=n,o=r=Date.now();var h=a.changedTouches;h.length>0&&(e.x=h[0].clientX/t.width*2-1,e.x0=e.x,e.y=2*-(h[0].clientY/t.height)+1,e.y0=e.y),e.rotation.speedX=e.rotation.speedY=0}),t.addEventListener(\"touchend\",function(a){if(i==n){a.preventDefault(),a.stopPropagation();var r=Date.now()-o;if(!(r>400)){var h,s,p=a.changedTouches;p.length>0&&(h=p[0].clientX/t.width*2-1,s=2*-(p[0].clientY/t.height)+1);var d=Math.max(Math.abs(e.x0-h),Math.abs(e.y0-s));d>.05||(e._tap=!0)}}}),t.addEventListener(\"touchmove\",function(a){if(i==n){a.preventDefault();var o,h,s=a.changedTouches;if(s.length>0){o=s[0].clientX/t.width*2-1,h=2*-(s[0].clientY/t.height)+1;var p=Date.now(),d=Math.max(.001,p-r);e.rotation.speedY=(o-e.x)/d,e.rotation.speedX=(h-e.y)/d,e.x=o,e.y=h,r=p}}}),t.addEventListener(\"mousedown\",function(n){n.preventDefault(),n.stopPropagation(),i=a,o=r=Date.now(),e.x=n.clientX/t.width*2-1,e.x0=e.x,e.y=2*-(n.clientY/t.height)+1,e.y0=e.y,e.rotation.speedX=e.rotation.speedY=0}),t.addEventListener(\"mouseup\",function(n){if(i==a){i=0,n.preventDefault(),n.stopPropagation();var r=Date.now()-o;if(!(r>400)){var h,s;h=n.clientX/t.width*2-1,s=2*-(n.clientY/t.height)+1;var p=Math.max(Math.abs(e.x0-h),Math.abs(e.y0-s));p>.05||(e._tap=!0)}}}),t.addEventListener(\"mousemove\",function(n){if(i==a){n.preventDefault();var o,h;n.changedTouches;o=n.clientX/t.width*2-1,h=2*-(n.clientY/t.height)+1;var s=Date.now(),p=Math.max(.001,s-r);e.rotation.speedY=(o-e.x)/p,e.rotation.speedX=(h-e.y)/p,e.x=o,e.y=h,r=s}})});i.prototype.applyRotation=function(t,e){var a=this.rotation.speedX*e,n=-this.rotation.speedY*e,i=Math.cos(a),o=Math.sin(a),r=Math.cos(n),h=Math.sin(n);t.matrixAutoUpdate=!1;var s=new THREE.Matrix4,p=s.elements;p[0]=r,p[1]=0,p[2]=h,p[3]=0,p[4]=o*h,p[5]=i,p[6]=-r*o,p[7]=0,p[8]=-i*h,p[9]=o,p[10]=i*r,p[11]=0,p[12]=0,p[13]=0,p[14]=0,p[15]=1,t.matrix=s.multiply(t.matrix)},i.prototype.tap=function(){return this._tap?(this._tap=!1,!0):!1},e.exports=i};\n//# sourceMappingURL=taquin.rotate-touch.js.map","map":{"version":3,"file":"taquin.rotate-touch.js.map","sources":["taquin.rotate-touch.js"],"sourcesContent":["window['#taquin.rotate-touch']=function(exports,module){  var MOUSEDOWN = 1;\r\nvar TOUCHSTART = 2;\r\n\r\nvar X_AXIS = new THREE.Vector3(1,0,0);\r\nvar Y_AXIS = new THREE.Vector3(0,1,0);\r\n\r\n/**\r\n * Deal with touch/mouse gestures to make an object rotate.\r\n *\r\n * @param canvas {canvas} - the canvas on with we will attach touch/mouse events.\r\n * @param mesh {THREE.Mesh} - the object to rotate according to gestures.\r\n */\r\nvar RotateTouch = function(canvas) {\r\n    var that = this;\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this._tap = false;\r\n    this.rotation = { speedX: Math.random() * .01, speedY: Math.random() * .01 };\r\n    var status = 0;\r\n    var timeTouchStart = 0;\r\n    var time0 = 0;\r\n    canvas.addEventListener(\"touchstart\", function(evt) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        status = TOUCHSTART;\r\n        timeTouchStart = time0 = Date.now();\r\n        var touches = evt.changedTouches;\r\n        if (touches.length > 0) {\r\n            that.x = ( touches[0].clientX / canvas.width ) * 2 - 1;\r\n            that.x0 = that.x;\r\n            that.y = -( touches[0].clientY / canvas.height ) * 2 + 1;\r\n            that.y0 = that.y;\r\n        }\r\n        // Stop rotation as soon as the user touches the screen.\r\n        that.rotation.speedX = that.rotation.speedY = 0;\r\n    });\r\n    canvas.addEventListener(\"touchend\", function(evt) {\r\n        if (status != TOUCHSTART) return;\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        var deltaTime = Date.now() - timeTouchStart;\r\n        if (deltaTime > 400) return;\r\n        var x, y;\r\n        var touches = evt.changedTouches;\r\n        if (touches.length > 0) {\r\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\r\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\r\n        }\r\n        var dis = Math.max(Math.abs(that.x0 - x), Math.abs(that.y0 - y));\r\n        if (dis > 0.05) return;\r\n        that._tap = true;\r\n    });\r\n    canvas.addEventListener(\"touchmove\", function(evt) {\r\n        if (status != TOUCHSTART) return;\r\n        evt.preventDefault();\r\n        var touches = evt.changedTouches;\r\n        var x, y;\r\n        if (touches.length > 0) {\r\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\r\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\r\n            var time1 = Date.now();\r\n            var deltaTime = Math.max(0.001, time1 - time0);\r\n            that.rotation.speedY = (x - that.x) / deltaTime;\r\n            that.rotation.speedX = (y - that.y) / deltaTime;\r\n            that.x = x;\r\n            that.y = y;\r\n            time0 = time1;\r\n        }\r\n    });\r\n\r\n    canvas.addEventListener(\"mousedown\", function(evt) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        status = MOUSEDOWN;\r\n        timeTouchStart = time0 = Date.now();\r\n        that.x = ( evt.clientX / canvas.width ) * 2 - 1;\r\n        that.x0 = that.x;\r\n        that.y = -( evt.clientY / canvas.height ) * 2 + 1;\r\n        that.y0 = that.y;\r\n        // Stop rotation as soon as the user touches the screen.\r\n        that.rotation.speedX = that.rotation.speedY = 0;\r\n    });\r\n    canvas.addEventListener(\"mouseup\", function(evt) {\r\n        if (status != MOUSEDOWN) return;\r\n        status = 0;\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n        var deltaTime = Date.now() - timeTouchStart;\r\n        if (deltaTime > 400) return;\r\n        var x, y;\r\n        x = ( evt.clientX / canvas.width ) * 2 - 1;\r\n        y = -( evt.clientY / canvas.height ) * 2 + 1;\r\n        var dis = Math.max(Math.abs(that.x0 - x), Math.abs(that.y0 - y));\r\n        if (dis > 0.05) return;\r\n        that._tap = true;\r\n    });\r\n    canvas.addEventListener(\"mousemove\", function(evt) {\r\n        if (status != MOUSEDOWN) return;\r\n        evt.preventDefault();\r\n        var touches = evt.changedTouches;\r\n        var x, y;\r\n        x = ( evt.clientX / canvas.width ) * 2 - 1;\r\n        y = -( evt.clientY / canvas.height ) * 2 + 1;\r\n        var time1 = Date.now();\r\n        var deltaTime = Math.max(0.001, time1 - time0);\r\n        that.rotation.speedY = (x - that.x) / deltaTime;\r\n        that.rotation.speedX = (y - that.y) / deltaTime;\r\n        that.x = x;\r\n        that.y = y;\r\n        time0 = time1;\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nRotateTouch.prototype.applyRotation = function(mesh, deltaTime) {\r\n    var angX = this.rotation.speedX * deltaTime;\r\n    var angY = -this.rotation.speedY * deltaTime;\r\n    var Cx = Math.cos(angX);\r\n    var Sx = Math.sin(angX);\r\n    var Cy = Math.cos(angY);\r\n    var Sy = Math.sin(angY);\r\n    mesh.matrixAutoUpdate = false;\r\n    var rotation = new THREE.Matrix4();\r\n    var e = rotation.elements;\r\n    e[0]  = Cy;      e[1]  = 0;      e[2]  = Sy;      e[3]  = 0;\r\n    e[4]  = Sx*Sy;   e[5]  = Cx;     e[6]  = -Cy*Sx;  e[7]  = 0;\r\n    e[8]  = -Cx*Sy;  e[9]  = Sx;     e[10] = Cx*Cy;   e[11] = 0;\r\n    e[12] = 0;       e[13] = 0;      e[14] = 0;       e[15] = 1;\r\n\r\n    mesh.matrix = rotation.multiply( mesh.matrix );\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nRotateTouch.prototype.tap = function() {\r\n    if (this._tap) {\r\n        this._tap = false;\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n\r\nmodule.exports = RotateTouch;\r\n }\n"],"names":["window","exports","module","MOUSEDOWN","TOUCHSTART","RotateTouch","THREE","Vector3","canvas","that","this","x","y","_tap","rotation","speedX","Math","random","speedY","status","timeTouchStart","time0","addEventListener","evt","preventDefault","stopPropagation","Date","now","touches","changedTouches","length","clientX","width","x0","clientY","height","y0","deltaTime","dis","max","abs","time1","prototype","applyRotation","mesh","angX","angY","Cx","cos","Sx","sin","Cy","Sy","matrixAutoUpdate","Matrix4","e","elements","matrix","multiply","tap"],"mappings":"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"},"dependencies":[]}