{"intl":"","src":"window['#taquin.rotate-touch']=function(exports,module){  var MOUSEDOWN = 1;\nvar TOUCHSTART = 2;\n\nvar X_AXIS = new THREE.Vector3(1,0,0);\nvar Y_AXIS = new THREE.Vector3(0,1,0);\n\n/**\n * Deal with touch/mouse gestures to make an object rotate.\n *\n * @param canvas {canvas} - the canvas on with we will attach touch/mouse events.\n * @param mesh {THREE.Mesh} - the object to rotate according to gestures.\n */\nvar RotateTouch = function(canvas) {\n    var that = this;\n    this.x = 0;\n    this.y = 0;\n    this._tap = false;\n    this.rotation = { speedX: Math.random() * .01, speedY: Math.random() * .01 };\n    var status = 0;\n    var timeTouchStart = 0;\n    var time0 = 0;\n    canvas.addEventListener(\"touchstart\", function(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        status = TOUCHSTART;\n        timeTouchStart = time0 = Date.now();\n        var touches = evt.changedTouches;\n        if (touches.length > 0) {\n            that.x = ( touches[0].clientX / canvas.width ) * 2 - 1;\n            that.x0 = that.x;\n            that.y = -( touches[0].clientY / canvas.height ) * 2 + 1;\n            that.y0 = that.y;\n        }\n        // Stop rotation as soon as the user touches the screen.\n        that.rotation.speedX = that.rotation.speedY = 0;\n    });\n    canvas.addEventListener(\"touchend\", function(evt) {\n        if (status != TOUCHSTART) return;\n        evt.preventDefault();\n        evt.stopPropagation();\n        var deltaTime = Date.now() - timeTouchStart;\n        if (deltaTime > 400) return;\n        var x, y;\n        var touches = evt.changedTouches;\n        if (touches.length > 0) {\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\n        }\n        var dis = Math.max(Math.abs(that.x0 - x), Math.abs(that.y0 - y));\n        if (dis > 0.05) return;\n        that._tap = true;\n    });\n    canvas.addEventListener(\"touchmove\", function(evt) {\n        if (status != TOUCHSTART) return;\n        evt.preventDefault();\n        var touches = evt.changedTouches;\n        var x, y;\n        if (touches.length > 0) {\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\n            var time1 = Date.now();\n            var deltaTime = Math.max(0.001, time1 - time0);\n            that.rotation.speedY = (x - that.x) / deltaTime;\n            that.rotation.speedX = (y - that.y) / deltaTime;\n            that.x = x;\n            that.y = y;\n            time0 = time1;\n        }\n    });\n};\n\n\n/**\n * @return void\n */\nRotateTouch.prototype.applyRotation = function(mesh, deltaTime) {\n    var angX = this.rotation.speedX * deltaTime;\n    var angY = -this.rotation.speedY * deltaTime;\n    var Cx = Math.cos(angX);\n    var Sx = Math.sin(angX);\n    var Cy = Math.cos(angY);\n    var Sy = Math.sin(angY);\n    mesh.matrixAutoUpdate = false;\n    var rotation = new THREE.Matrix4();\n    var e = rotation.elements;\n    e[0]  = Cy;      e[1]  = 0;      e[2]  = Sy;      e[3]  = 0;\n    e[4]  = Sx*Sy;   e[5]  = Cx;     e[6]  = -Cy*Sx;  e[7]  = 0;\n    e[8]  = -Cx*Sy;  e[9]  = Sx;     e[10] = Cx*Cy;   e[11] = 0;\n    e[12] = 0;       e[13] = 0;      e[14] = 0;       e[15] = 1;\n\n    mesh.matrix = rotation.multiply( mesh.matrix );\n};\n\n\n/**\n * @return void\n */\nRotateTouch.prototype.tap = function() {\n    if (this._tap) {\n        this._tap = false;\n        return true;\n    }\n    return false;\n};\n\n\nmodule.exports = RotateTouch;\n }\n","zip":"window[\"#taquin.rotate-touch\"]=function(t,e){var a=2,n=(new THREE.Vector3(1,0,0),new THREE.Vector3(0,1,0),function(t){var e=this;this.x=0,this.y=0,this._tap=!1,this.rotation={speedX:.01*Math.random(),speedY:.01*Math.random()};var n=0,i=0,o=0;t.addEventListener(\"touchstart\",function(h){h.preventDefault(),h.stopPropagation(),n=a,i=o=Date.now();var r=h.changedTouches;r.length>0&&(e.x=r[0].clientX/t.width*2-1,e.x0=e.x,e.y=2*-(r[0].clientY/t.height)+1,e.y0=e.y),e.rotation.speedX=e.rotation.speedY=0}),t.addEventListener(\"touchend\",function(o){if(n==a){o.preventDefault(),o.stopPropagation();var h=Date.now()-i;if(!(h>400)){var r,s,p=o.changedTouches;p.length>0&&(r=p[0].clientX/t.width*2-1,s=2*-(p[0].clientY/t.height)+1);var c=Math.max(Math.abs(e.x0-r),Math.abs(e.y0-s));c>.05||(e._tap=!0)}}}),t.addEventListener(\"touchmove\",function(i){if(n==a){i.preventDefault();var h,r,s=i.changedTouches;if(s.length>0){h=s[0].clientX/t.width*2-1,r=2*-(s[0].clientY/t.height)+1;var p=Date.now(),c=Math.max(.001,p-o);e.rotation.speedY=(h-e.x)/c,e.rotation.speedX=(r-e.y)/c,e.x=h,e.y=r,o=p}}})});n.prototype.applyRotation=function(t,e){var a=this.rotation.speedX*e,n=-this.rotation.speedY*e,i=Math.cos(a),o=Math.sin(a),h=Math.cos(n),r=Math.sin(n);t.matrixAutoUpdate=!1;var s=new THREE.Matrix4,p=s.elements;p[0]=h,p[1]=0,p[2]=r,p[3]=0,p[4]=o*r,p[5]=i,p[6]=-h*o,p[7]=0,p[8]=-i*r,p[9]=o,p[10]=i*h,p[11]=0,p[12]=0,p[13]=0,p[14]=0,p[15]=1,t.matrix=s.multiply(t.matrix)},n.prototype.tap=function(){return this._tap?(this._tap=!1,!0):!1},e.exports=n};\n//# sourceMappingURL=taquin.rotate-touch.js.map","map":{"version":3,"file":"taquin.rotate-touch.js.map","sources":["taquin.rotate-touch.js"],"sourcesContent":["window['#taquin.rotate-touch']=function(exports,module){  var MOUSEDOWN = 1;\nvar TOUCHSTART = 2;\n\nvar X_AXIS = new THREE.Vector3(1,0,0);\nvar Y_AXIS = new THREE.Vector3(0,1,0);\n\n/**\n * Deal with touch/mouse gestures to make an object rotate.\n *\n * @param canvas {canvas} - the canvas on with we will attach touch/mouse events.\n * @param mesh {THREE.Mesh} - the object to rotate according to gestures.\n */\nvar RotateTouch = function(canvas) {\n    var that = this;\n    this.x = 0;\n    this.y = 0;\n    this._tap = false;\n    this.rotation = { speedX: Math.random() * .01, speedY: Math.random() * .01 };\n    var status = 0;\n    var timeTouchStart = 0;\n    var time0 = 0;\n    canvas.addEventListener(\"touchstart\", function(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        status = TOUCHSTART;\n        timeTouchStart = time0 = Date.now();\n        var touches = evt.changedTouches;\n        if (touches.length > 0) {\n            that.x = ( touches[0].clientX / canvas.width ) * 2 - 1;\n            that.x0 = that.x;\n            that.y = -( touches[0].clientY / canvas.height ) * 2 + 1;\n            that.y0 = that.y;\n        }\n        // Stop rotation as soon as the user touches the screen.\n        that.rotation.speedX = that.rotation.speedY = 0;\n    });\n    canvas.addEventListener(\"touchend\", function(evt) {\n        if (status != TOUCHSTART) return;\n        evt.preventDefault();\n        evt.stopPropagation();\n        var deltaTime = Date.now() - timeTouchStart;\n        if (deltaTime > 400) return;\n        var x, y;\n        var touches = evt.changedTouches;\n        if (touches.length > 0) {\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\n        }\n        var dis = Math.max(Math.abs(that.x0 - x), Math.abs(that.y0 - y));\n        if (dis > 0.05) return;\n        that._tap = true;\n    });\n    canvas.addEventListener(\"touchmove\", function(evt) {\n        if (status != TOUCHSTART) return;\n        evt.preventDefault();\n        var touches = evt.changedTouches;\n        var x, y;\n        if (touches.length > 0) {\n            x = ( touches[0].clientX / canvas.width ) * 2 - 1;\n            y = -( touches[0].clientY / canvas.height ) * 2 + 1;\n            var time1 = Date.now();\n            var deltaTime = Math.max(0.001, time1 - time0);\n            that.rotation.speedY = (x - that.x) / deltaTime;\n            that.rotation.speedX = (y - that.y) / deltaTime;\n            that.x = x;\n            that.y = y;\n            time0 = time1;\n        }\n    });\n};\n\n\n/**\n * @return void\n */\nRotateTouch.prototype.applyRotation = function(mesh, deltaTime) {\n    var angX = this.rotation.speedX * deltaTime;\n    var angY = -this.rotation.speedY * deltaTime;\n    var Cx = Math.cos(angX);\n    var Sx = Math.sin(angX);\n    var Cy = Math.cos(angY);\n    var Sy = Math.sin(angY);\n    mesh.matrixAutoUpdate = false;\n    var rotation = new THREE.Matrix4();\n    var e = rotation.elements;\n    e[0]  = Cy;      e[1]  = 0;      e[2]  = Sy;      e[3]  = 0;\n    e[4]  = Sx*Sy;   e[5]  = Cx;     e[6]  = -Cy*Sx;  e[7]  = 0;\n    e[8]  = -Cx*Sy;  e[9]  = Sx;     e[10] = Cx*Cy;   e[11] = 0;\n    e[12] = 0;       e[13] = 0;      e[14] = 0;       e[15] = 1;\n\n    mesh.matrix = rotation.multiply( mesh.matrix );\n};\n\n\n/**\n * @return void\n */\nRotateTouch.prototype.tap = function() {\n    if (this._tap) {\n        this._tap = false;\n        return true;\n    }\n    return false;\n};\n\n\nmodule.exports = RotateTouch;\n }\n"],"names":["window","exports","module","TOUCHSTART","RotateTouch","THREE","Vector3","canvas","that","this","x","y","_tap","rotation","speedX","Math","random","speedY","status","timeTouchStart","time0","addEventListener","evt","preventDefault","stopPropagation","Date","now","touches","changedTouches","length","clientX","width","x0","clientY","height","y0","deltaTime","dis","max","abs","time1","prototype","applyRotation","mesh","angX","angY","Cx","cos","Sx","sin","Cy","Sy","matrixAutoUpdate","Matrix4","e","elements","matrix","multiply","tap"],"mappings":"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"},"dependencies":[]}